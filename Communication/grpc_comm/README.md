# 0 相关概念
gRPC 是一个高性能、开源、通用的 远程过程调用（RPC）框架，由 Google 开发并开源。其核心特性包括基于 HTTP/2 协议 和 Protocol Buffers（Protobuf）序列化，支持跨语言开发和多种通信模式（如单向、流式等）。

TCP 和 HTTP/2 是 不同层次的协议，共同协作完成数据传输：TCP 确保数据在网络中可靠传递，HTTP/2 在 TCP 基础上优化应用层数据交互效率。两者结合实现了从底层传输到上层语义的完整通信链路。

**gRPC and socket 关系**

```shell
gRPC 应用层
    ↓
HTTP/2 协议层
    ↓
TLS/SSL 安全层 (可选)
    ↓
TCP Socket 层
    ↓
操作系统网络栈
    ↓
物理网络
```

# 1 环境安装

```sh
pip install grpcio grpcio-tools protobuf
```

# 2 编译proto文件
```proto
syntax = "proto3";

package example;

// 定义服务接口
service HelloService {
  // 单向请求响应模式
  rpc SendMessage (HelloRequest) returns (HelloResponse) {}
}

// 请求消息类型
message HelloRequest {
  string name = 1;
}

// 响应消息类型
message HelloResponse {
  string message = 1;
}
```

# 3 生成python文件
```bash
# 生成python代码
# grpc_tools.protoc 是 Python 的 grpcio-tools 包中的一个模块，
# 主要用于通过 Protocol Buffers (protobuf) 编译器 (protoc) 生成 gRPC 客户端和服务端的代码。
# 也可添加--pyi_out 选项, 用于生成与 .proto 对应的 Python 类型接口文件，提升代码的可维护性和类型安全性。
python -m grpc_tools.protoc  -I. --python_out=. --grpc_python_out=. hello.proto

# 生成两个文件
# - `hello_pb2.py` ：数据序列化类
# - `hello_pb2_grpc.py` ：gRPC服务接口类

# 也可程序Java/Go/C++ 等类型代码
```

# 4 生成的文件
## 4.1 hell_pb2.py
```python
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: hello.proto
# Protobuf Python Version: 5.29.0
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    5,
    29,
    0,
    '',
    'hello.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x0bhello.proto\x12\x07\x65xample\"\x1c\n\x0cHelloRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\" \n\rHelloResponse\x12\x0f\n\x07message\x18\x01 \x01(\t2N\n\x0cHelloService\x12>\n\x0bSendMessage\x12\x15.example.HelloRequest\x1a\x16.example.HelloResponse\"\x00\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'hello_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  DESCRIPTOR._loaded_options = None
  _globals['_HELLOREQUEST']._serialized_start=24
  _globals['_HELLOREQUEST']._serialized_end=52
  _globals['_HELLORESPONSE']._serialized_start=54
  _globals['_HELLORESPONSE']._serialized_end=86
  _globals['_HELLOSERVICE']._serialized_start=88
  _globals['_HELLOSERVICE']._serialized_end=166
# @@protoc_insertion_point(module_scope)
```

## 4.2 hello_pb2_grpc.py
```python
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import hello_pb2 as hello__pb2

GRPC_GENERATED_VERSION = '1.71.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in hello_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )

# 客户端存根(stub)类，用于向客户端提供远程服务接口的本地代理：
# 将客户调用方法，映射到对应的gRPC端口，负责序列化请求对象，发送RPC请求，接受并反序列化响应对象.
class HelloServiceStub(object):
    """定义服务接口
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.SendMessage = channel.unary_unary(
                # 告诉gRPC要调用哪个服务的哪个方法，客户端和服务端必须使用相同的路径才能正确匹配RPC方法;
                # gRPC 内部通过这个字符串来定位服务和方法，而不是通过类或函数名。
                # 协议一致性要求：gRPC 使用统一的 URI 格式来标识方法，确保跨语言兼容性
                # Uniform Resource Identifiler (URI): /<Package>.<Service>/<Method>
                '/example.HelloService/SendMessage',
                request_serializer=hello__pb2.HelloRequest.SerializeToString,
                response_deserializer=hello__pb2.HelloResponse.FromString,
                _registered_method=True)


class HelloServiceServicer(object):
    """定义服务接口
    """

    def SendMessage(self, request, context):
        """单向请求响应模式
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


# 将一个服务实现(servicer) 注册到gRPC 服务器 server 中, 使得服务器可用处理可用端对该服务的RPC请求,
# servicer 具体实现了上面 HelloServiceServicer 类.
def add_HelloServiceServicer_to_server(servicer, server):
    # dict :
    rpc_method_handlers = {
            'SendMessage': grpc.unary_unary_rpc_method_handler(                     # 一元请求，一元响应：客户端发送一次请求，服务端返回一次响应；
                    servicer.SendMessage,                                           # 具体的服务方法
                    request_deserializer=hello__pb2.HelloRequest.FromString,        # client端请求反序列方式
                    response_serializer=hello__pb2.HelloResponse.SerializeToString, # server端响应序列化方式
            ),
    }

    # 通用服务处理器：generic_handler 是 gRPC内部用于处理该服务所有方法的统一入口.
    generic_handler = grpc.method_handlers_generic_handler(
            'example.HelloService', rpc_method_handlers)

    # 把这个服务的handler注册到服务器中, 这样服务器就指导如何处理来自example.HelloService的请求了
    server.add_generic_rpc_handlers((generic_handler,))
    # 记录服务方法的元信息(metadata)，便于后续查询或调试使用;
    server.add_registered_method_handlers('example.HelloService', rpc_method_handlers)


# This class is part of an EXPERIMENTAL API.
# 此函数没有用到
class HelloService(object):
    """定义服务接口
    """

    @staticmethod
    def SendMessage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/example.HelloService/SendMessage',
            hello__pb2.HelloRequest.SerializeToString,
            hello__pb2.HelloResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
```


# 5 编写服务端代码
```python
import grpc
import hello_pb2
import hello_pb2_grpc
from concurrent import futures

class HelloServiceServicer(hello_pb2_grpc.HelloServiceServicer):
    def SendMessage(self, request, context):
        response = hello_pb2.HelloResponse()
        response.message  = f"Hello, {request.name}!"
        return response

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    hello_pb2_grpc.add_HelloServiceServicer_to_server(
        HelloServiceServicer(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    print("Server started on port 50051")
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
```

# 6 编写客户端代码
```python
import grpc
import hello_pb2
import hello_pb2_grpc

def run():
    channel = grpc.insecure_channel('localhost:50051')
    stub = hello_pb2_grpc.HelloServiceStub(channel)

    request = hello_pb2.HelloRequest(name="World")
    response = stub.SendMessage(request)

    print("Received:", response.message)

if __name__ == '__main__':
    run()
```

# 7 comm 原理

```python
# Client 端 和 Server 端调用流程
# Client                     Server
#    │                           │
#    ├─────── SendMessage ──────►
#    │       (HelloRequest)      │
#    │                           │
#    ◄─────── Response ──────────┤
#    │       (HelloResponse)     │
```

# 8 代码运行

## 4.5 运行服务端和客户端
```bash
python server.py

# other terminal
python client.py

# 输出：Received: Hello, World!
```