# 1. 隐式同步
在 CUDA 中，某些操作会触发**隐式同步**（Implicit Synchronization），即这些操作会自动等待设备上的所有先前任务完成后再继续执行。以下是常见的隐式同步操作：

## 1.1 **`cudaMemcpy`**
   - 当调用 `cudaMemcpy` 在主机和设备之间复制数据时：
     - 如果是从设备到主机 (`cudaMemcpyDeviceToHost`)，CUDA 会确保所有之前的设备操作（如内核执行）已完成。
     - 如果是从主机到设备 (`cudaMemcpyHostToDevice`)，CUDA 也会确保之前的操作完成，但这种情况较少涉及隐式同步。

## 1.2. **`cudaMalloc` 和 `cudaFree`**
   - 调用 `cudaMalloc` 分配设备内存或 `cudaFree` 释放设备内存时，CUDA 会隐式同步以确保没有其他操作正在使用相关内存。


## 1.3. **主机访问设备内存**
   - 如果主机尝试访问设备内存（例如通过零拷贝内存或映射内存），CUDA 会隐式同步以确保设备上的所有操作已完成。

## 1.4. **程序终止**
   - 当 CUDA 程序结束时，CUDA 运行时会隐式同步所有设备操作，以确保所有未完成的任务都已执行完毕。

## 1.5. **某些 API 调用**
   - 以下 API 调用可能会触发隐式同步：
     - `cudaMemset`：设置设备内存时，可能会等待之前的任务完成。
     - `cudaStreamSynchronize`：显式同步流时，会等待该流中的所有任务完成。
     - `cudaDeviceSynchronize`：显式同步整个设备时，会等待所有任务完成。

## 1.6. **内核启动后的主机操作**
   - 如果主机在启动内核后立即尝试访问设备资源（例如读取结果或检查状态），CUDA 会隐式同步以确保内核执行完成。

## 1.7 注意事项
- 隐式同步可能会导致性能问题，因为它会强制主机等待设备完成所有任务。为了提高性能，可以尽量避免隐式同步，改用显式同步（如 `cudaStreamSynchronize` 或 `cudaEventSynchronize`）来更精细地控制同步点。
- 使用 CUDA 流（Streams）可以实现异步操作，从而减少隐式同步的影响。

